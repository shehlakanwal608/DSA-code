#include <iostream>          
#include <queue>             
using namespace std;         
//binary node
template <class T>
class BinaryNode {
public:
    T data;                  // data stored in the node
    BinaryNode<T>* leftChild;  // pointer to left child
    BinaryNode<T>* rightChild; // pointer to right child

    // Constructor to initialize node
    BinaryNode(T val) {
        data = val;          // assign value to node
        leftChild = nullptr; // initialize left child as null
        rightChild = nullptr;// initialize right child as null
    }

    // Return data stored in node
    T retrieve() {
        return data;   // return node value
    }

    // Check if node is a leaf
    bool isLeaf() {
        return (leftChild == nullptr && rightChild == nullptr); // no children
    }

    // Count total nodes in tree
    int size() {
        int count = 1;       // count current node
        if (leftChild)       // if left child exists
            count += leftChild->size(); // add left subtree size
        if (rightChild)      // if right child exists
            count += rightChild->size();// add right subtree size
        return count;        // return total count
    }

    // Calculate height of tree
    int height() {
        int lh = 0, rh = 0;  // left and right subtree heights
        if (leftChild)      // if left child exists
            lh = leftChild->height(); // get left height
        if (rightChild)     // if right child exists
            rh = rightChild->height();// get right height
        return 1 + max(lh, rh); // return max height + current node
    }

    // Search a value in tree
    bool search(T key) {
        if (data == key)    // if current node matches
            return true;
        bool found = false; // flag to store result
        if (leftChild)      // search in left subtree
            found = leftChild->search(key);
        if (!found && rightChild) // if not found, search right subtree
            found = rightChild->search(key);
        return found;       // return search result
    }

    // Delete entire subtree
    void clear() {
        if (leftChild) {    // if left child exists
            leftChild->clear(); // clear left subtree
            delete leftChild;   // delete left child
        }
        if (rightChild) {   // if right child exists
            rightChild->clear();// clear right subtree
            delete rightChild;  // delete right child
        }
    }
};

//Binary tree
template <class T>
class BinaryTree {
private:
    BinaryNode<T>* rootNode; // pointer to root of tree

    // Inorder traversal helper
    void inorder(BinaryNode<T>* node) {
        if (!node) return;  // base case
        inorder(node->leftChild); // visit left subtree
        cout << node->retrieve() << " "; // visit root
        inorder(node->rightChild); // visit right subtree
    }

    // Preorder traversal helper
    void preorder(BinaryNode<T>* node) {
        if (!node) return;  // base case
        cout << node->retrieve() << " "; // visit root
        preorder(node->leftChild); // visit left subtree
        preorder(node->rightChild);// visit right subtree
    }

    // Postorder traversal helper
    void postorder(BinaryNode<T>* node) {
        if (!node) return;  // base case
        postorder(node->leftChild); // visit left subtree
        postorder(node->rightChild);// visit right subtree
        cout << node->retrieve() << " "; // visit root
    }

public:
    // Constructor
    BinaryTree() {
        rootNode = nullptr; // initialize empty tree
    }

    // Check if tree is empty
    bool empty() {
        return rootNode == nullptr; // true if no root
    }

    // Return root node
    BinaryNode<T>* root() {
        return rootNode;    // return root pointer
    }

    // Level-order insertion (General Binary Tree)
    void insert(T value) {
        BinaryNode<T>* newNode = new BinaryNode<T>(value); // create new node

        if (rootNode == nullptr) { // if tree is empty
            rootNode = newNode;    // make new node root
            return;
        }

        queue<BinaryNode<T>*> q;  // queue for level-order traversal
        q.push(rootNode);         // push root into queue

        while (!q.empty()) {      // loop until queue is empty
            BinaryNode<T>* temp = q.front(); // get front node
            q.pop();              // remove front node

            if (temp->leftChild == nullptr) { // if left child empty
                temp->leftChild = newNode;   // insert as left child
                return;
            }
            else {
                q.push(temp->leftChild);     // push left child
            }

            if (temp->rightChild == nullptr) { // if right child empty
                temp->rightChild = newNode;    // insert as right child
                return;
            }
            else {
                q.push(temp->rightChild);      // push right child
            }
        }
    }

    // Return size of tree
    int size() {
        if (!rootNode) return 0;  // if tree empty
        return rootNode->size();  // return size from root
    }

    // Return height of tree
    int height() {
        if (!rootNode) return 0;  // if tree empty
        return rootNode->height();// return height from root
    }

    // Inorder traversal
    void inorderTraversal() {
        inorder(rootNode);    
        cout << endl;
    }

    // Preorder traversal
    void preorderTraversal() {
        preorder(rootNode);      
        cout << endl;
    }

    // Postorder traversal
    void postorderTraversal() {
        postorder(rootNode);     
        cout << endl;
    }

    // Delete entire tree
    void clear() {
        if (rootNode) {           // if tree not empty
            rootNode->clear();    // clear all nodes
            delete rootNode;      // delete root
            rootNode = nullptr;   // set root to null
        }
    }
};

int main() {
    BinaryTree<int> tree;   

    // Insert elements 
    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);
    tree.insert(50);

    cout << "Inorder: ";
    tree.inorderTraversal();     

    cout << "Preorder: ";
    tree.preorderTraversal();     

    cout << "Postorder: ";
    tree.postorderTraversal();    

    cout << "Size: " << tree.size() << endl;  
    cout << "Height: " << tree.height() << endl;

    tree.clear();                 
    return 0;                     
}
