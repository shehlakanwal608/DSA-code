#include <iostream>
using namespace std;
class Node {
private:
    int data;       // stores value of node
    Node* next;     // pointer to next node
    Node* prev;     // pointer to previous node

public:
    // Constructor with default parameters
    Node(int d = 0, Node* n = nullptr, Node* p = nullptr) {
        data = d;   // set data
        next = n;   // set next pointer
        prev = p;   // set previous pointer
    }

    // Setter for data
    void setData(int val) {
        data = val;
    }

    // Setter for next pointer
    void setNext(Node* n) {
        next = n;
    }

    // Setter for previous pointer
    void setPrev(Node* p) {
        prev = p;
    }

    // Getter for data
    int retreive() const {
        return data;
    }

    // Getter for next pointer
    Node* getNext() const {
        return next;
    }

    // Getter for previous pointer
    Node* getPrev() const {
        return prev;
    }
};

// Circular doubly linked list class
class CircularDoublyList {
private:
    Node* head;  // pointer to first node
    Node* tail;  // pointer to last node

public:
    // Constructor
    CircularDoublyList() {
        head = nullptr; // initially head is null
        tail = nullptr; // initially tail is null
    }

    // Destructor: delete all nodes
    ~CircularDoublyList() {
        while (!empty()) {
            pop_front(); // delete front node until list is empty
        }
    }
    // empty
    bool empty() const {
        return head == nullptr;
    }
    int front() const {
        if (empty()) {
            cout << "List is empty.\n";
            return -1;
        }
        return head->retreive(); // return data using getter
    }
    int end() const {
        if (empty()) {
            cout << "List is empty.\n";
            return -1;
        }
        return tail->retreive(); // return tail data
    }
    // Get size of list
    int size() const {
        if (empty()) return 0;      // empty list has size 0
        int count = 0;
        Node* p = head;
        do {
            count++;                  // count current node
            p = p->getNext();         // move to next node using getter
        } while (p != head);          // stop when looped back to head
        return count;
    }
    // Count
    int countValue(int val) const {
        if (empty()) return 0;
        int c = 0;
        Node* p = head;
        do {
            if (p->retreive() == val) { // compare data
                c++;
            }
            p = p->getNext(); // move to next node
        } while (p != head);  // until looped back to head
        return c;
    }
    void display() const {
        if (empty()) {
            cout << "List is empty.\n";
            return;
        }
        cout << "List elements: ";
        Node* p = head;
        do {
            cout << p->retreive() << " "; // print data using getter
            p = p->getNext();             // move to next node
        } while (p != head);               // stop when back to head
        cout << endl;
    }
    // Insert at front
    void push_front(int val) {
        Node* newNode = new Node(val);    // create new node
        if (empty()) {  
            head = newNode; // head points to new node
            tail = newNode; // tail points to new node
            newNode->setNext(head); // next points to itself
            newNode->setPrev(tail); // prev points to itself
        }
        else {                      
            newNode->setNext(head);// new node points to old head
            newNode->setPrev(tail);// new node prev points to tail
            head->setPrev(newNode);// old head prev points to new node
            tail->setNext(newNode);// tail next points to new node
            head = newNode;// update head to new node
        }
    }
    // Insert at end
    void push_back(int val) {
        Node* newNode = new Node(val);// create new node
        if (empty()) {
            head = newNode;
            tail = newNode;
            newNode->setNext(head); // next points to itself
            newNode->setPrev(tail); // prev points to itself
        }
        else {
            newNode->setPrev(tail);// new node prev points to old tail
            newNode->setNext(head);// new node next points to head
            tail->setNext(newNode);// old tail next points to new node
            head->setPrev(newNode);// head prev points to new node
            tail = newNode;// update tail
        }
    }
    void pop_front() {
        if (empty()) {// list empty
            cout << "List is empty.\n";
            return;
        }
        Node* temp = head;// store old head
        if (head == tail) {// only one node
            head = nullptr;
            tail = nullptr;
        }
        else {
            head = head->getNext();// update head to next node
            head->setPrev(tail);// new head prev points to tail
            tail->setNext(head);// tail next points to new head
        }
        delete temp;// free memory of old head
    }

    // Delete last node
    void pop_back() {
        if (empty()) {                      
            cout << "List is empty.\n";
            return;
        }
        Node* temp = tail;// store old tail
        if (head == tail) {
            head = nullptr;
            tail = nullptr;
        }
        else {
            tail = tail->getPrev();// update tail to previous node
            tail->setNext(head);// tail next points to head
            head->setPrev(tail);// head prev points to tail
        }
        delete temp; // delete old tail
    }

    // Insert at specific position
    void insertion(int pos, int val) {
        int length = size();// get total nodes
        if (pos < 0 || pos > length) {
            cout << "Invalid position.\n";
            return;
        }
        if (pos == 0) {// insert at front
            push_front(val);
            return;
        }
        if (pos == length) {// insert at end
            push_back(val);
            return;
        }
        Node* prev = head;
        for (int i = 0; i < pos - 1; i++) {
            prev = prev->getNext();// move to node before position
        }
        Node* nextNode = prev->getNext();// node currently at position
        Node* newNode = new Node(val, nextNode, prev); // set next and prev
        prev->setNext(newNode); // previous node points to new node
        nextNode->setPrev(newNode); // next node prev points to new node
    }

    // Delete node at specific position
    void erase(int pos) {
        int length = size();// total nodes
        if (pos < 0 || pos >= length) {
            cout << "Invalid position.\n";
            return;
        }
        if (pos == 0) {
            pop_front();
            return;
        }
        if (pos == length - 1) {
            pop_back();
            return;
        }
        Node* prev = head; // start from head
        for (int i = 0; i < pos - 1; i++) {
            prev = prev->getNext();          // move to node before target
        }
        Node* delNode = prev->getNext();      // node to delete
        Node* nextNode = delNode->getNext();  // node after delNode
        prev->setNext(nextNode);              // link previous to next
        nextNode->setPrev(prev);              // link next back to previous
        delete delNode;                        // free memory
    }
};

// Main function
int main() {
    CircularDoublyList li;

    li.push_front(10);
    li.push_front(20);
    li.push_back(30);
    li.push_back(40);
    li.push_back(50);
    li.display();
    cout << "Head element: " << li.front() << endl;
    cout << "Tail element: " << li.end() << endl;

    li.pop_front();
    li.display();
    cout << "Head element: " << li.front() << endl;
    cout << "Tail element: " << li.end() << endl;

    li.pop_back();
    li.display();

    li.insertion(1, 60);
    li.display();

    li.erase(0);
    li.display();

    return 0;
}
